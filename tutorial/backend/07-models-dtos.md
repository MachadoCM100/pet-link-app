# Models and Data Transfer Objects

## Overview

The PetLink API uses strongly-typed models and DTOs (Data Transfer Objects) to ensure type safety, data validation, and clear contracts between the API and clients. The models are organized in the `Models` namespace and follow .NET naming conventions.

## Model Architecture

### 1. Entity Models
- Core business entities (Pet)
- Properties with appropriate data types
- Default value initialization

### 2. Authentication DTOs
- Request/Response objects for auth flow
- Record types for immutable data
- Clear separation of concerns

### 3. Validation Integration
- ASP.NET Core model validation
- Automatic validation through attributes
- ModelState integration

## Pet Entity Model

### Pet.cs - Core Pet Entity

```csharp
namespace PetLink.API.Models
{
    public class Pet
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public bool Adopted { get; set; }
    }
}
```

#### Property Analysis

**Id (int)**:
- **Purpose**: Unique identifier for each pet
- **Usage**: Auto-generated by service layer
- **Type**: Integer for simplicity in demo
- **Future**: Could be GUID for distributed systems

**Name (string)**:
- **Purpose**: Pet's name for display and identification
- **Default**: Empty string (prevents null reference issues)
- **Validation**: Required field (can be added with attributes)
- **Usage**: User-friendly identifier

**Type (string)**:
- **Purpose**: Category of pet (Cat, Dog, Bird, etc.)
- **Default**: Empty string for safety
- **Pattern**: Free-form text (could be enum in future)
- **Usage**: Filtering and categorization

**Adopted (bool)**:
- **Purpose**: Tracks adoption status
- **Default**: False (new pets not adopted)
- **Business Logic**: Changed through AdoptPet operation
- **Usage**: Availability filtering

### Model Usage in Controllers

#### Request Binding

```csharp
[HttpPost]
public async Task<IActionResult> CreatePet([FromBody] Pet pet)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
    
    var createdPet = await _petService.CreatePetAsync(pet);
    return CreatedAtAction(nameof(GetPet), new { id = createdPet.Id }, createdPet);
}
```

**[FromBody]**: Binds JSON request body to Pet object
**ModelState**: Automatic validation state tracking
**Type Safety**: Compile-time type checking

#### Response Serialization

```csharp
[HttpGet]
public async Task<IActionResult> GetPets()
{
    var pets = await _petService.GetAllPetsAsync();
    return Ok(pets); // Automatic JSON serialization
}
```

**Automatic JSON**: ASP.NET Core serializes Pet objects to JSON
**Consistent Format**: All endpoints return same Pet structure
**Type Information**: Client libraries can generate typed clients

## Authentication Models

### AuthModels.cs - Authentication DTOs

```csharp
namespace PetLink.API.Models
{
    public record LoginRequest(string Username, string Password);

    public class LoginResponse
    {
        public string Token { get; set; } = string.Empty;
    }

    public class User
    {
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
```

### LoginRequest - Input DTO

#### Record Type Benefits

```csharp
public record LoginRequest(string Username, string Password);
```

**Immutability**: Cannot be modified after creation
**Value Equality**: Compares by value, not reference
**Concise Syntax**: Automatic property generation
**Thread Safety**: Immutable objects are inherently thread-safe

#### Usage Pattern

```csharp
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] LoginRequest request)
{
    var result = await _authService.AuthenticateAsync(request);
    // request.Username and request.Password are available
}
```

**Automatic Binding**: JSON → LoginRequest object
**Type Safety**: Compile-time validation of property access
**Validation**: Can add data annotations for validation

### LoginResponse - Output DTO

#### Class Design

```csharp
public class LoginResponse
{
    public string Token { get; set; } = string.Empty;
}
```

**Mutable Class**: Allows setting token after creation
**Default Value**: Prevents null reference exceptions
**Extensible**: Easy to add additional response properties

#### Usage Pattern

```csharp
public Task<LoginResponse?> AuthenticateAsync(LoginRequest request)
{
    // ... authentication logic
    var token = GenerateJwtToken(request.Username);
    return Task.FromResult<LoginResponse?>(new LoginResponse { Token = token });
}
```

**Factory Pattern**: Created by service after successful auth
**Nullable Return**: Null indicates failed authentication
**JSON Response**: Automatically serialized to client

### User - Entity Model

#### Future Database Integration

```csharp
public class User
{
    public string Username { get; set; } = string.Empty;
    public string Password { get; set; } = string.Empty;
}
```

**Purpose**: Prepared for database storage of users
**Current State**: Not actively used (demo credentials in service)
**Future Use**: Entity Framework integration, password hashing
**Security Note**: In production, passwords would be hashed

## Model Validation

### ASP.NET Core Integration

#### Automatic Validation

```csharp
if (!ModelState.IsValid)
    return BadRequest(ModelState);
```

**ModelState**: Framework tracks validation errors
**Automatic Binding**: Validation runs during model binding
**Error Response**: BadRequest returns validation details

#### Data Annotations (Future Enhancement)

```csharp
public class Pet
{
    public int Id { get; set; }
    
    [Required]
    [StringLength(100)]
    public string Name { get; set; } = string.Empty;
    
    [Required]
    public string Type { get; set; } = string.Empty;
    
    public bool Adopted { get; set; }
}
```

**[Required]**: Ensures property has value
**[StringLength]**: Limits string length
**Framework Integration**: Automatic validation in controllers

### Error Response Format

#### Validation Errors

```json
{
  "Name": ["The Name field is required."],
  "Type": ["The Type field is required."]
}
```

**Structure**: Property name → error messages array
**Client-Friendly**: Clear field-specific error messages
**Framework Generated**: Consistent error format

## JSON Serialization

### Default Behavior

#### Property Names

```json
{
  "id": 1,
  "name": "Fluffy",
  "type": "Cat", 
  "adopted": false
}
```

**Camel Case**: .NET properties → camelCase JSON (default)
**Consistent**: All endpoints use same naming convention
**Standard**: Follows JavaScript/TypeScript conventions

#### Configuration Options

```csharp
// In Program.cs - for custom JSON settings
builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
});
```

**Customizable**: Can change naming policy if needed
**Global Settings**: Applies to all API responses
**Framework Integration**: Built into ASP.NET Core

## Best Practices Implemented

### 1. Type Safety
- Strong typing throughout the application
- Compile-time error detection
- IntelliSense support for developers

### 2. Null Safety
- Default values for string properties
- Nullable reference types awareness
- Reduced null reference exceptions

### 3. Immutability (where appropriate)
- Record types for input DTOs
- Value equality semantics
- Thread-safe data structures

### 4. Separation of Concerns
- Different models for different purposes
- Clear boundaries between layers
- Dedicated DTOs for API contracts

### 5. Framework Integration
- Automatic model binding
- Built-in validation support
- JSON serialization integration

## Future Enhancements

### 1. Validation Attributes
- Add data annotation validation
- Custom validation rules
- Cross-property validation

### 2. Database Integration
- Entity Framework Core models
- Database migration support
- Relationship mapping

### 3. API Versioning
- Versioned DTOs for API evolution
- Backward compatibility
- Contract versioning strategy

### 4. Documentation
- XML documentation comments
- OpenAPI/Swagger integration
- Client code generation

## Next Steps

- [API Project Structure](./01-api-structure.md)
- [Authentication and JWT](./02-authentication-jwt.md)
- [Controllers and Endpoints](./03-controllers-endpoints.md)
- [Service Layer Architecture](./06-service-layer-architecture.md)
